import * as i0 from '@angular/core';
import { Directive, Inject, Optional, Input, NgModule } from '@angular/core';
import { MatTooltip, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltipModule } from '@angular/material/tooltip';
import * as i5 from 'rt-define-stroke-width';
import { RtDefineStrokeWidthModule } from 'rt-define-stroke-width';
import { WINDOW, RtPlatformModule } from 'rt-platform';
import { DOCUMENT } from '@angular/common';
import { Subscription, Observable } from 'rxjs';
import * as i1 from '@angular/cdk/overlay';
import * as i2 from '@angular/cdk/platform';
import * as i3 from '@angular/cdk/a11y';
import * as i4 from '@angular/cdk/bidi';

class RtOverflowTooltipDirective extends MatTooltip {
    rtDefineStrokeWidth;
    /** The message to be displayed in the tooltip if the element has not enough space. */
    rtOverflowTooltip;
    /** Host element of the directive. */
    hostElement;
    /** Text content of the host element. */
    hostElementText;
    /** CSS rules applied to the host element. */
    computedStyle;
    /** Font CSS style rule applied to the host element. */
    fontString;
    /** Letter spacing CSS style rule applied to the host element. */
    letterSpacing;
    paddingLeft;
    paddingRight;
    borderLeft;
    borderRight;
    /** Component subscriptions. Will be unsubscribed on destroy. */
    subscription = new Subscription();
    /** Global window object. */
    window;
    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document, rtDefineStrokeWidth, _window) {
        super(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document);
        this.rtDefineStrokeWidth = rtDefineStrokeWidth;
        // Assign host element.
        this.hostElement = _elementRef.nativeElement;
        // Assign global window object.
        this.window = _window;
    }
    ngOnInit() {
        // Apply provided tooltip text to the element.
        this.message = this.rtOverflowTooltip;
        // Subscribe to resize event on the host element and update tooltip display logic.
        this.subscription.add(this.observeHostElementResize().subscribe(() => this.updateElementDisplayLogic()));
    }
    updateElementDisplayLogic() {
        this.updateElementProperties();
        // Calculate the width of the spaces with the applied letter spacing rule.
        const letterSpacingAmendment = this.hostElement.innerText.length * parseFloat(this.letterSpacing);
        // Calculate the width of the text content with the applied font rule without actual rendering it.
        const calculatedStringWidth = this.rtDefineStrokeWidth.getTextWidth(this.hostElement.innerText, this.fontString);
        const calculatedContentWidth = calculatedStringWidth + letterSpacingAmendment;
        const area = parseFloat(this.borderLeft) + parseFloat(this.borderRight) + parseFloat(this.paddingLeft) + parseFloat(this.paddingRight);
        // Calculate the actual width of the host element.
        const actualContentWidth = this.hostElement.getBoundingClientRect().width - 3 - area;
        // Disable tooltip if the text content is not overflowing (all the content is on the page, so no need to show tooltip).
        this.disabled = calculatedContentWidth <= actualContentWidth;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * Observe resize event on the provided element.
     */
    observeHostElementResize() {
        return new Observable(subscriber => {
            const resizeObserver = new ResizeObserver(entries => {
                subscriber.next(entries);
            });
            resizeObserver.observe(this.hostElement);
            return () => {
                resizeObserver.unobserve(this.hostElement);
            };
        });
    }
    /**
     * Update local variables with the current state of the host element.
     */
    updateElementProperties() {
        this.hostElementText = this.hostElement.innerText;
        this.computedStyle = this.window.getComputedStyle(this.hostElement);
        this.fontString = this.computedStyle.getPropertyValue('font');
        this.letterSpacing = this.computedStyle.getPropertyValue('letter-spacing');
        this.paddingLeft = this.computedStyle.getPropertyValue('padding-left');
        this.paddingRight = this.computedStyle.getPropertyValue('padding-right');
        this.borderLeft = this.computedStyle.getPropertyValue('border-left');
        this.borderRight = this.computedStyle.getPropertyValue('border-right');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i1.ScrollDispatcher }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i2.Platform }, { token: i3.AriaDescriber }, { token: i3.FocusMonitor }, { token: MAT_TOOLTIP_SCROLL_STRATEGY }, { token: i4.Directionality, optional: true }, { token: MAT_TOOLTIP_DEFAULT_OPTIONS, optional: true }, { token: DOCUMENT, optional: true }, { token: i5.RtDefineStrokeWidthService }, { token: WINDOW, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: RtOverflowTooltipDirective, selector: "[rtOverflowTooltip]", inputs: { rtOverflowTooltip: "rtOverflowTooltip" }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rtOverflowTooltip]',
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i1.ScrollDispatcher }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i2.Platform }, { type: i3.AriaDescriber }, { type: i3.FocusMonitor }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_TOOLTIP_SCROLL_STRATEGY]
                }] }, { type: i4.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAT_TOOLTIP_DEFAULT_OPTIONS]
                }] }, { type: Document, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i5.RtDefineStrokeWidthService }, { type: Window, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [WINDOW]
                }] }]; }, propDecorators: { rtOverflowTooltip: [{
                type: Input
            }] } });

class RtOverflowTooltipModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipModule, declarations: [RtOverflowTooltipDirective], imports: [RtDefineStrokeWidthModule,
            MatTooltipModule,
            RtPlatformModule], exports: [RtOverflowTooltipDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipModule, imports: [RtDefineStrokeWidthModule,
            MatTooltipModule,
            RtPlatformModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RtOverflowTooltipDirective],
                    imports: [
                        RtDefineStrokeWidthModule,
                        MatTooltipModule,
                        RtPlatformModule,
                    ],
                    exports: [RtOverflowTooltipDirective],
                }]
        }] });

/*
 * Public API Surface of rt-overflow-tooltip
 */

/**
 * Generated bundle index. Do not edit.
 */

export { RtOverflowTooltipDirective, RtOverflowTooltipModule };
//# sourceMappingURL=rt-overflow-tooltip.mjs.map
