import { DOCUMENT } from '@angular/common';
import { Directive, Inject, Input, Optional, } from '@angular/core';
import { MAT_TOOLTIP_DEFAULT_OPTIONS, MAT_TOOLTIP_SCROLL_STRATEGY, MatTooltip, } from '@angular/material/tooltip';
import { WINDOW } from 'rt-platform';
import { Observable, Subscription } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/cdk/platform";
import * as i3 from "@angular/cdk/a11y";
import * as i4 from "@angular/cdk/bidi";
import * as i5 from "rt-define-stroke-width";
class RtOverflowTooltipDirective extends MatTooltip {
    rtDefineStrokeWidth;
    /** The message to be displayed in the tooltip if the element has not enough space. */
    rtOverflowTooltip;
    /** Host element of the directive. */
    hostElement;
    /** Text content of the host element. */
    hostElementText;
    /** CSS rules applied to the host element. */
    computedStyle;
    /** Font CSS style rule applied to the host element. */
    fontString;
    /** Letter spacing CSS style rule applied to the host element. */
    letterSpacing;
    paddingLeft;
    paddingRight;
    borderLeft;
    borderRight;
    /** Component subscriptions. Will be unsubscribed on destroy. */
    subscription = new Subscription();
    /** Global window object. */
    window;
    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document, rtDefineStrokeWidth, _window) {
        super(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document);
        this.rtDefineStrokeWidth = rtDefineStrokeWidth;
        // Assign host element.
        this.hostElement = _elementRef.nativeElement;
        // Assign global window object.
        this.window = _window;
    }
    ngOnInit() {
        // Apply provided tooltip text to the element.
        this.message = this.rtOverflowTooltip;
        // Subscribe to resize event on the host element and update tooltip display logic.
        this.subscription.add(this.observeHostElementResize().subscribe(() => this.updateElementDisplayLogic()));
    }
    updateElementDisplayLogic() {
        this.updateElementProperties();
        // Calculate the width of the spaces with the applied letter spacing rule.
        const letterSpacingAmendment = this.hostElement.innerText.length * parseFloat(this.letterSpacing);
        // Calculate the width of the text content with the applied font rule without actual rendering it.
        const calculatedStringWidth = this.rtDefineStrokeWidth.getTextWidth(this.hostElement.innerText, this.fontString);
        const calculatedContentWidth = calculatedStringWidth + letterSpacingAmendment;
        const area = parseFloat(this.borderLeft) + parseFloat(this.borderRight) + parseFloat(this.paddingLeft) + parseFloat(this.paddingRight);
        // Calculate the actual width of the host element.
        const actualContentWidth = this.hostElement.getBoundingClientRect().width - 3 - area;
        // Disable tooltip if the text content is not overflowing (all the content is on the page, so no need to show tooltip).
        this.disabled = calculatedContentWidth <= actualContentWidth;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * Observe resize event on the provided element.
     */
    observeHostElementResize() {
        return new Observable(subscriber => {
            const resizeObserver = new ResizeObserver(entries => {
                subscriber.next(entries);
            });
            resizeObserver.observe(this.hostElement);
            return () => {
                resizeObserver.unobserve(this.hostElement);
            };
        });
    }
    /**
     * Update local variables with the current state of the host element.
     */
    updateElementProperties() {
        this.hostElementText = this.hostElement.innerText;
        this.computedStyle = this.window.getComputedStyle(this.hostElement);
        this.fontString = this.computedStyle.getPropertyValue('font');
        this.letterSpacing = this.computedStyle.getPropertyValue('letter-spacing');
        this.paddingLeft = this.computedStyle.getPropertyValue('padding-left');
        this.paddingRight = this.computedStyle.getPropertyValue('padding-right');
        this.borderLeft = this.computedStyle.getPropertyValue('border-left');
        this.borderRight = this.computedStyle.getPropertyValue('border-right');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i1.ScrollDispatcher }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i2.Platform }, { token: i3.AriaDescriber }, { token: i3.FocusMonitor }, { token: MAT_TOOLTIP_SCROLL_STRATEGY }, { token: i4.Directionality, optional: true }, { token: MAT_TOOLTIP_DEFAULT_OPTIONS, optional: true }, { token: DOCUMENT, optional: true }, { token: i5.RtDefineStrokeWidthService }, { token: WINDOW, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: RtOverflowTooltipDirective, selector: "[rtOverflowTooltip]", inputs: { rtOverflowTooltip: "rtOverflowTooltip" }, usesInheritance: true, ngImport: i0 });
}
export { RtOverflowTooltipDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rtOverflowTooltip]',
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i1.ScrollDispatcher }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i2.Platform }, { type: i3.AriaDescriber }, { type: i3.FocusMonitor }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_TOOLTIP_SCROLL_STRATEGY]
                }] }, { type: i4.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAT_TOOLTIP_DEFAULT_OPTIONS]
                }] }, { type: Document, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i5.RtDefineStrokeWidthService }, { type: Window, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [WINDOW]
                }] }]; }, propDecorators: { rtOverflowTooltip: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9ydC1vdmVyZmxvdy10b29sdGlwL3NyYy9saWIvcnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFDTCxTQUFTLEVBRVQsTUFBTSxFQUNOLEtBQUssRUFJTCxRQUFRLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLDJCQUEyQixFQUMzQiwyQkFBMkIsRUFDM0IsVUFBVSxHQUVYLE1BQU0sMkJBQTJCLENBQUM7QUFFbkMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNuQyxPQUFPLEVBQUMsVUFBVSxFQUFFLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQzs7Ozs7OztBQUU5QyxNQUdhLDBCQUEyQixTQUFRLFVBQVU7SUFvQzlDO0lBbkNWLHNGQUFzRjtJQUM3RSxpQkFBaUIsQ0FBUztJQUNuQyxxQ0FBcUM7SUFDM0IsV0FBVyxDQUFjO0lBQ25DLHdDQUF3QztJQUM5QixlQUFlLENBQVM7SUFDbEMsNkNBQTZDO0lBQ25DLGFBQWEsQ0FBc0I7SUFDN0MsdURBQXVEO0lBQzdDLFVBQVUsQ0FBVTtJQUM5QixpRUFBaUU7SUFDdkQsYUFBYSxDQUFTO0lBQ3RCLFdBQVcsQ0FBUztJQUNwQixZQUFZLENBQVM7SUFDckIsVUFBVSxDQUFTO0lBQ25CLFdBQVcsQ0FBUztJQUM5QixnRUFBZ0U7SUFDL0MsWUFBWSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7SUFDbkQsNEJBQTRCO0lBQ3BCLE1BQU0sQ0FBUztJQUV2QixZQUNFLFFBQWlCLEVBQ2pCLFdBQXVCLEVBQ3ZCLGlCQUFtQyxFQUNuQyxpQkFBbUMsRUFDbkMsT0FBZSxFQUNmLFNBQW1C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L2Nkay9hMTF5JztcbmltcG9ydCB7RGlyZWN0aW9uYWxpdHl9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7T3ZlcmxheSwgU2Nyb2xsRGlzcGF0Y2hlcn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHtQbGF0Zm9ybX0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7RE9DVU1FTlR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIE1BVF9UT09MVElQX0RFRkFVTFRfT1BUSU9OUyxcbiAgTUFUX1RPT0xUSVBfU0NST0xMX1NUUkFURUdZLFxuICBNYXRUb29sdGlwLFxuICBNYXRUb29sdGlwRGVmYXVsdE9wdGlvbnMsXG59IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3Rvb2x0aXAnO1xuaW1wb3J0IHtDU1NGb250LCBSdERlZmluZVN0cm9rZVdpZHRoU2VydmljZX0gZnJvbSAncnQtZGVmaW5lLXN0cm9rZS13aWR0aCc7XG5pbXBvcnQge1dJTkRPV30gZnJvbSAncnQtcGxhdGZvcm0nO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcnRPdmVyZmxvd1Rvb2x0aXBdJyxcbn0pXG5leHBvcnQgY2xhc3MgUnRPdmVyZmxvd1Rvb2x0aXBEaXJlY3RpdmUgZXh0ZW5kcyBNYXRUb29sdGlwIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAvKiogVGhlIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwIGlmIHRoZSBlbGVtZW50IGhhcyBub3QgZW5vdWdoIHNwYWNlLiAqL1xuICBASW5wdXQoKSBydE92ZXJmbG93VG9vbHRpcDogc3RyaW5nO1xuICAvKiogSG9zdCBlbGVtZW50IG9mIHRoZSBkaXJlY3RpdmUuICovXG4gIHByb3RlY3RlZCBob3N0RWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gIC8qKiBUZXh0IGNvbnRlbnQgb2YgdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgcHJvdGVjdGVkIGhvc3RFbGVtZW50VGV4dDogc3RyaW5nO1xuICAvKiogQ1NTIHJ1bGVzIGFwcGxpZWQgdG8gdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgcHJvdGVjdGVkIGNvbXB1dGVkU3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb247XG4gIC8qKiBGb250IENTUyBzdHlsZSBydWxlIGFwcGxpZWQgdG8gdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgcHJvdGVjdGVkIGZvbnRTdHJpbmc6IENTU0ZvbnQ7XG4gIC8qKiBMZXR0ZXIgc3BhY2luZyBDU1Mgc3R5bGUgcnVsZSBhcHBsaWVkIHRvIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIHByb3RlY3RlZCBsZXR0ZXJTcGFjaW5nOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBwYWRkaW5nTGVmdDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcGFkZGluZ1JpZ2h0OiBzdHJpbmc7XG4gIHByb3RlY3RlZCBib3JkZXJMZWZ0OiBzdHJpbmc7XG4gIHByb3RlY3RlZCBib3JkZXJSaWdodDogc3RyaW5nO1xuICAvKiogQ29tcG9uZW50IHN1YnNjcmlwdGlvbnMuIFdpbGwgYmUgdW5zdWJzY3JpYmVkIG9uIGRlc3Ryb3kuICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAvKiogR2xvYmFsIHdpbmRvdyBvYmplY3QuICovXG4gIHByaXZhdGUgd2luZG93OiBXaW5kb3c7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgX3Njcm9sbERpc3BhdGNoZXI6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgX25nWm9uZTogTmdab25lLFxuICAgIF9wbGF0Zm9ybTogUGxhdGZvcm0sXG4gICAgX2FyaWFEZXNjcmliZXI6IEFyaWFEZXNjcmliZXIsXG4gICAgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLFxuICAgIEBJbmplY3QoTUFUX1RPT0xUSVBfU0NST0xMX1NUUkFURUdZKSBfc2Nyb2xsU3RyYXRlZ3k6IHVua25vd24sXG4gICAgQE9wdGlvbmFsKCkgX2RpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRfVE9PTFRJUF9ERUZBVUxUX09QVElPTlMpXG4gICAgICBfZGVmYXVsdE9wdGlvbnM6IE1hdFRvb2x0aXBEZWZhdWx0T3B0aW9ucyxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBfZG9jdW1lbnQ6IERvY3VtZW50LFxuICAgIHByaXZhdGUgcnREZWZpbmVTdHJva2VXaWR0aDogUnREZWZpbmVTdHJva2VXaWR0aFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChXSU5ET1cpIF93aW5kb3c6IFdpbmRvdyxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBfb3ZlcmxheSxcbiAgICAgIF9lbGVtZW50UmVmLFxuICAgICAgX3Njcm9sbERpc3BhdGNoZXIsXG4gICAgICBfdmlld0NvbnRhaW5lclJlZixcbiAgICAgIF9uZ1pvbmUsXG4gICAgICBfcGxhdGZvcm0sXG4gICAgICBfYXJpYURlc2NyaWJlcixcbiAgICAgIF9mb2N1c01vbml0b3IsXG4gICAgICBfc2Nyb2xsU3RyYXRlZ3ksXG4gICAgICBfZGlyLFxuICAgICAgX2RlZmF1bHRPcHRpb25zLFxuICAgICAgX2RvY3VtZW50LFxuICAgICk7XG4gICAgLy8gQXNzaWduIGhvc3QgZWxlbWVudC5cbiAgICB0aGlzLmhvc3RFbGVtZW50ID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgIC8vIEFzc2lnbiBnbG9iYWwgd2luZG93IG9iamVjdC5cbiAgICB0aGlzLndpbmRvdyA9IF93aW5kb3c7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgIC8vIEFwcGx5IHByb3ZpZGVkIHRvb2x0aXAgdGV4dCB0byB0aGUgZWxlbWVudC5cbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnJ0T3ZlcmZsb3dUb29sdGlwO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlc2l6ZSBldmVudCBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCB1cGRhdGUgdG9vbHRpcCBkaXNwbGF5IGxvZ2ljLlxuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgIHRoaXMub2JzZXJ2ZUhvc3RFbGVtZW50UmVzaXplKCkuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlRWxlbWVudERpc3BsYXlMb2dpYygpKSxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUVsZW1lbnREaXNwbGF5TG9naWMoKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50UHJvcGVydGllcygpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgc3BhY2VzIHdpdGggdGhlIGFwcGxpZWQgbGV0dGVyIHNwYWNpbmcgcnVsZS5cbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nQW1lbmRtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5pbm5lclRleHQubGVuZ3RoICogcGFyc2VGbG9hdCh0aGlzLmxldHRlclNwYWNpbmcpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgdGV4dCBjb250ZW50IHdpdGggdGhlIGFwcGxpZWQgZm9udCBydWxlIHdpdGhvdXQgYWN0dWFsIHJlbmRlcmluZyBpdC5cbiAgICBjb25zdCBjYWxjdWxhdGVkU3RyaW5nV2lkdGggPSB0aGlzLnJ0RGVmaW5lU3Ryb2tlV2lkdGguZ2V0VGV4dFdpZHRoKHRoaXMuaG9zdEVsZW1lbnQuaW5uZXJUZXh0LCB0aGlzLmZvbnRTdHJpbmcpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRDb250ZW50V2lkdGggPSBjYWxjdWxhdGVkU3RyaW5nV2lkdGggKyBsZXR0ZXJTcGFjaW5nQW1lbmRtZW50O1xuXG5cbiAgICBjb25zdCBhcmVhID0gcGFyc2VGbG9hdCh0aGlzLmJvcmRlckxlZnQpICsgcGFyc2VGbG9hdCh0aGlzLmJvcmRlclJpZ2h0KSArIHBhcnNlRmxvYXQodGhpcy5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KHRoaXMucGFkZGluZ1JpZ2h0KTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYWN0dWFsIHdpZHRoIG9mIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgY29uc3QgYWN0dWFsQ29udGVudFdpZHRoID0gdGhpcy5ob3N0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIDMgLSBhcmVhO1xuXG4gICAgLy8gRGlzYWJsZSB0b29sdGlwIGlmIHRoZSB0ZXh0IGNvbnRlbnQgaXMgbm90IG92ZXJmbG93aW5nIChhbGwgdGhlIGNvbnRlbnQgaXMgb24gdGhlIHBhZ2UsIHNvIG5vIG5lZWQgdG8gc2hvdyB0b29sdGlwKS5cbiAgICB0aGlzLmRpc2FibGVkID0gY2FsY3VsYXRlZENvbnRlbnRXaWR0aCA8PSBhY3R1YWxDb250ZW50V2lkdGg7XG5cbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSByZXNpemUgZXZlbnQgb24gdGhlIHByb3ZpZGVkIGVsZW1lbnQuXG4gICAqL1xuICBwcm90ZWN0ZWQgb2JzZXJ2ZUhvc3RFbGVtZW50UmVzaXplKCk6IE9ic2VydmFibGU8UmVzaXplT2JzZXJ2ZXJFbnRyeVtdPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZXIgPT4ge1xuICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChlbnRyaWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgbG9jYWwgdmFyaWFibGVzIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGhvc3QgZWxlbWVudC5cbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVFbGVtZW50UHJvcGVydGllcygpOiB2b2lkIHtcbiAgICB0aGlzLmhvc3RFbGVtZW50VGV4dCA9IHRoaXMuaG9zdEVsZW1lbnQuaW5uZXJUZXh0O1xuICAgIHRoaXMuY29tcHV0ZWRTdHlsZSA9IHRoaXMud2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgdGhpcy5mb250U3RyaW5nID0gdGhpcy5jb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQnKTtcbiAgICB0aGlzLmxldHRlclNwYWNpbmcgPSB0aGlzLmNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdGhpcy5jb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctbGVmdCcpO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdGhpcy5jb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICB0aGlzLmJvcmRlckxlZnQgPSB0aGlzLmNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLWxlZnQnKTtcbiAgICB0aGlzLmJvcmRlclJpZ2h0ID0gdGhpcy5jb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1yaWdodCcpO1xuICB9XG59XG4iXX0=