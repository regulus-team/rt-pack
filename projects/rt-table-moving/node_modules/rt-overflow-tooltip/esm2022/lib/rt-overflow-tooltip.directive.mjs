import { DOCUMENT } from '@angular/common';
import { Directive, Inject, Input, Optional, } from '@angular/core';
import { MAT_TOOLTIP_DEFAULT_OPTIONS, MAT_TOOLTIP_SCROLL_STRATEGY, MatTooltip, } from '@angular/material/tooltip';
import { WINDOW } from 'rt-platform';
import { Observable, Subscription } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/cdk/platform";
import * as i3 from "@angular/cdk/a11y";
import * as i4 from "@angular/cdk/bidi";
import * as i5 from "rt-define-stroke-width";
class RtOverflowTooltipDirective extends MatTooltip {
    rtDefineStrokeWidth;
    /** The message to be displayed in the tooltip if the element has not enough space. */
    rtOverflowTooltip;
    /** Host element of the directive. */
    hostElement;
    /** Text content of the host element. */
    hostElementText;
    /** CSS rules applied to the host element. */
    computedStyle;
    /** Font CSS style rule applied to the host element. */
    fontString;
    /** Letter spacing CSS style rule applied to the host element. */
    letterSpacing;
    /** Component subscriptions. Will be unsubscribed on destroy. */
    subscription = new Subscription();
    /** Global window object. */
    window;
    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document, rtDefineStrokeWidth, _window) {
        super(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document);
        this.rtDefineStrokeWidth = rtDefineStrokeWidth;
        // Assign host element.
        this.hostElement = _elementRef.nativeElement;
        // Assign global window object.
        this.window = _window;
    }
    ngOnInit() {
        // Apply provided tooltip text to the element.
        this.message = this.rtOverflowTooltip;
        // Subscribe to resize event on the host element and update tooltip display logic.
        this.subscription.add(this.observeHostElementResize().subscribe(() => this.updateElementDisplayLogic()));
    }
    updateElementDisplayLogic() {
        this.updateElementProperties();
        // Calculate the width of the spaces with the applied letter spacing rule.
        const letterSpacingAmendment = this.hostElement.innerText.length * parseFloat(this.letterSpacing);
        // Calculate the width of the text content with the applied font rule without actual rendering it.
        const calculatedStringWidth = this.rtDefineStrokeWidth.getTextWidth(this.hostElement.innerText, this.fontString);
        const calculatedContentWidth = calculatedStringWidth + letterSpacingAmendment;
        // Calculate the actual width of the host element.
        const actualContentWidth = this.hostElement.getBoundingClientRect().width - 15;
        // Disable tooltip if the text content is not overflowing (all the content is on the page, so no need to show tooltip).
        this.disabled = calculatedContentWidth <= actualContentWidth;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * Observe resize event on the provided element.
     */
    observeHostElementResize() {
        return new Observable(subscriber => {
            const resizeObserver = new ResizeObserver(entries => {
                subscriber.next(entries);
            });
            resizeObserver.observe(this.hostElement);
            return () => {
                resizeObserver.unobserve(this.hostElement);
            };
        });
    }
    /**
     * Update local variables with the current state of the host element.
     */
    updateElementProperties() {
        this.hostElementText = this.hostElement.innerText;
        this.computedStyle = this.window.getComputedStyle(this.hostElement);
        this.fontString = this.computedStyle.getPropertyValue('font');
        this.letterSpacing = this.computedStyle.getPropertyValue('letter-spacing');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i1.ScrollDispatcher }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i2.Platform }, { token: i3.AriaDescriber }, { token: i3.FocusMonitor }, { token: MAT_TOOLTIP_SCROLL_STRATEGY }, { token: i4.Directionality, optional: true }, { token: MAT_TOOLTIP_DEFAULT_OPTIONS, optional: true }, { token: DOCUMENT, optional: true }, { token: i5.RtDefineStrokeWidthService }, { token: WINDOW, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: RtOverflowTooltipDirective, selector: "[rtOverflowTooltip]", inputs: { rtOverflowTooltip: "rtOverflowTooltip" }, usesInheritance: true, ngImport: i0 });
}
export { RtOverflowTooltipDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rtOverflowTooltip]',
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i1.ScrollDispatcher }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i2.Platform }, { type: i3.AriaDescriber }, { type: i3.FocusMonitor }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_TOOLTIP_SCROLL_STRATEGY]
                }] }, { type: i4.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAT_TOOLTIP_DEFAULT_OPTIONS]
                }] }, { type: Document, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i5.RtDefineStrokeWidthService }, { type: Window, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [WINDOW]
                }] }]; }, propDecorators: { rtOverflowTooltip: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9ydC1vdmVyZmxvdy10b29sdGlwL3NyYy9saWIvcnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFDTCxTQUFTLEVBRVQsTUFBTSxFQUNOLEtBQUssRUFJTCxRQUFRLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLDJCQUEyQixFQUMzQiwyQkFBMkIsRUFDM0IsVUFBVSxHQUVYLE1BQU0sMkJBQTJCLENBQUM7QUFFbkMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNuQyxPQUFPLEVBQUMsVUFBVSxFQUFFLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQzs7Ozs7OztBQUU5QyxNQUdhLDBCQUEyQixTQUFRLFVBQVU7SUFnQzlDO0lBL0JWLHNGQUFzRjtJQUM3RSxpQkFBaUIsQ0FBUztJQUNuQyxxQ0FBcUM7SUFDM0IsV0FBVyxDQUFjO0lBQ25DLHdDQUF3QztJQUM5QixlQUFlLENBQVM7SUFDbEMsNkNBQTZDO0lBQ25DLGFBQWEsQ0FBc0I7SUFDN0MsdURBQXVEO0lBQzdDLFVBQVUsQ0FBVTtJQUM5QixpRUFBaUU7SUFDdkQsYUFBYSxDQUFTO0lBQ2hDLGdFQUFnRTtJQUMvQyxZQUFZLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQUNuRCw0QkFBNEI7SUFDcEIsTUFBTSxDQUFTO0lBRXZCLFlBQ0UsUUFBaUIsRUFDakIsV0FBdUIsRUFDdkIsaUJBQW1DLEVBQ25DLGlCQUFtQyxFQUNuQyxPQUFlLEVBQ2YsU0FBbUIsRUFDbkIsY0FBNkIsRUFDN0IsYUFBMkIsRUFDVSxlQUF3QixFQUNqRCxJQUFvQixFQUU5QixlQUF5QyxFQUNi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MkRBRWYsMkJBQTJCLDZCQUUzQixRQUFRLHVFQUVSLE1BQU07MkZBakNqQiwwQkFBMEI7O1NBQTFCLDBCQUEwQjsyRkFBMUIsMEJBQTBCO2tCQUh0QyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxxQkFBcUI7aUJBQ2hDOzswQkE0QkksTUFBTTsyQkFBQywyQkFBMkI7OzBCQUNsQyxRQUFROzswQkFDUixRQUFROzswQkFBSSxNQUFNOzJCQUFDLDJCQUEyQjs7MEJBRTlDLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsUUFBUTs7MEJBRTNCLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsTUFBTTs0Q0EvQm5CLGlCQUFpQjtzQkFBekIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QXJpYURlc2NyaWJlciwgRm9jdXNNb25pdG9yfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQge0RpcmVjdGlvbmFsaXR5fSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQge092ZXJsYXksIFNjcm9sbERpc3BhdGNoZXJ9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7UGxhdGZvcm19IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQge0RPQ1VNRU5UfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBNQVRfVE9PTFRJUF9ERUZBVUxUX09QVElPTlMsXG4gIE1BVF9UT09MVElQX1NDUk9MTF9TVFJBVEVHWSxcbiAgTWF0VG9vbHRpcCxcbiAgTWF0VG9vbHRpcERlZmF1bHRPcHRpb25zLFxufSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC90b29sdGlwJztcbmltcG9ydCB7Q1NTRm9udCwgUnREZWZpbmVTdHJva2VXaWR0aFNlcnZpY2V9IGZyb20gJ3J0LWRlZmluZS1zdHJva2Utd2lkdGgnO1xuaW1wb3J0IHtXSU5ET1d9IGZyb20gJ3J0LXBsYXRmb3JtJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3J0T3ZlcmZsb3dUb29sdGlwXScsXG59KVxuZXhwb3J0IGNsYXNzIFJ0T3ZlcmZsb3dUb29sdGlwRGlyZWN0aXZlIGV4dGVuZHMgTWF0VG9vbHRpcCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLyoqIFRoZSBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcCBpZiB0aGUgZWxlbWVudCBoYXMgbm90IGVub3VnaCBzcGFjZS4gKi9cbiAgQElucHV0KCkgcnRPdmVyZmxvd1Rvb2x0aXA6IHN0cmluZztcbiAgLyoqIEhvc3QgZWxlbWVudCBvZiB0aGUgZGlyZWN0aXZlLiAqL1xuICBwcm90ZWN0ZWQgaG9zdEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAvKiogVGV4dCBjb250ZW50IG9mIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIHByb3RlY3RlZCBob3N0RWxlbWVudFRleHQ6IHN0cmluZztcbiAgLyoqIENTUyBydWxlcyBhcHBsaWVkIHRvIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIHByb3RlY3RlZCBjb21wdXRlZFN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uO1xuICAvKiogRm9udCBDU1Mgc3R5bGUgcnVsZSBhcHBsaWVkIHRvIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIHByb3RlY3RlZCBmb250U3RyaW5nOiBDU1NGb250O1xuICAvKiogTGV0dGVyIHNwYWNpbmcgQ1NTIHN0eWxlIHJ1bGUgYXBwbGllZCB0byB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICBwcm90ZWN0ZWQgbGV0dGVyU3BhY2luZzogc3RyaW5nO1xuICAvKiogQ29tcG9uZW50IHN1YnNjcmlwdGlvbnMuIFdpbGwgYmUgdW5zdWJzY3JpYmVkIG9uIGRlc3Ryb3kuICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAvKiogR2xvYmFsIHdpbmRvdyBvYmplY3QuICovXG4gIHByaXZhdGUgd2luZG93OiBXaW5kb3c7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgX3Njcm9sbERpc3BhdGNoZXI6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgX25nWm9uZTogTmdab25lLFxuICAgIF9wbGF0Zm9ybTogUGxhdGZvcm0sXG4gICAgX2FyaWFEZXNjcmliZXI6IEFyaWFEZXNjcmliZXIsXG4gICAgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLFxuICAgIEBJbmplY3QoTUFUX1RPT0xUSVBfU0NST0xMX1NUUkFURUdZKSBfc2Nyb2xsU3RyYXRlZ3k6IHVua25vd24sXG4gICAgQE9wdGlvbmFsKCkgX2RpcjogRGlyZWN0aW9uYWxpdHksXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRfVE9PTFRJUF9ERUZBVUxUX09QVElPTlMpXG4gICAgICBfZGVmYXVsdE9wdGlvbnM6IE1hdFRvb2x0aXBEZWZhdWx0T3B0aW9ucyxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBfZG9jdW1lbnQ6IERvY3VtZW50LFxuICAgIHByaXZhdGUgcnREZWZpbmVTdHJva2VXaWR0aDogUnREZWZpbmVTdHJva2VXaWR0aFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChXSU5ET1cpIF93aW5kb3c6IFdpbmRvdyxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBfb3ZlcmxheSxcbiAgICAgIF9lbGVtZW50UmVmLFxuICAgICAgX3Njcm9sbERpc3BhdGNoZXIsXG4gICAgICBfdmlld0NvbnRhaW5lclJlZixcbiAgICAgIF9uZ1pvbmUsXG4gICAgICBfcGxhdGZvcm0sXG4gICAgICBfYXJpYURlc2NyaWJlcixcbiAgICAgIF9mb2N1c01vbml0b3IsXG4gICAgICBfc2Nyb2xsU3RyYXRlZ3ksXG4gICAgICBfZGlyLFxuICAgICAgX2RlZmF1bHRPcHRpb25zLFxuICAgICAgX2RvY3VtZW50LFxuICAgICk7XG4gICAgLy8gQXNzaWduIGhvc3QgZWxlbWVudC5cbiAgICB0aGlzLmhvc3RFbGVtZW50ID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgIC8vIEFzc2lnbiBnbG9iYWwgd2luZG93IG9iamVjdC5cbiAgICB0aGlzLndpbmRvdyA9IF93aW5kb3c7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgIC8vIEFwcGx5IHByb3ZpZGVkIHRvb2x0aXAgdGV4dCB0byB0aGUgZWxlbWVudC5cbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnJ0T3ZlcmZsb3dUb29sdGlwO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlc2l6ZSBldmVudCBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCB1cGRhdGUgdG9vbHRpcCBkaXNwbGF5IGxvZ2ljLlxuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgIHRoaXMub2JzZXJ2ZUhvc3RFbGVtZW50UmVzaXplKCkuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlRWxlbWVudERpc3BsYXlMb2dpYygpKSxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUVsZW1lbnREaXNwbGF5TG9naWMoKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50UHJvcGVydGllcygpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgc3BhY2VzIHdpdGggdGhlIGFwcGxpZWQgbGV0dGVyIHNwYWNpbmcgcnVsZS5cbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nQW1lbmRtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5pbm5lclRleHQubGVuZ3RoICogcGFyc2VGbG9hdCh0aGlzLmxldHRlclNwYWNpbmcpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgdGV4dCBjb250ZW50IHdpdGggdGhlIGFwcGxpZWQgZm9udCBydWxlIHdpdGhvdXQgYWN0dWFsIHJlbmRlcmluZyBpdC5cbiAgICBjb25zdCBjYWxjdWxhdGVkU3RyaW5nV2lkdGggPSB0aGlzLnJ0RGVmaW5lU3Ryb2tlV2lkdGguZ2V0VGV4dFdpZHRoKHRoaXMuaG9zdEVsZW1lbnQuaW5uZXJUZXh0LCB0aGlzLmZvbnRTdHJpbmcpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRDb250ZW50V2lkdGggPSBjYWxjdWxhdGVkU3RyaW5nV2lkdGggKyBsZXR0ZXJTcGFjaW5nQW1lbmRtZW50O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhY3R1YWwgd2lkdGggb2YgdGhlIGhvc3QgZWxlbWVudC5cbiAgICBjb25zdCBhY3R1YWxDb250ZW50V2lkdGggPSB0aGlzLmhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gMTU7XG5cbiAgICAvLyBEaXNhYmxlIHRvb2x0aXAgaWYgdGhlIHRleHQgY29udGVudCBpcyBub3Qgb3ZlcmZsb3dpbmcgKGFsbCB0aGUgY29udGVudCBpcyBvbiB0aGUgcGFnZSwgc28gbm8gbmVlZCB0byBzaG93IHRvb2x0aXApLlxuICAgIHRoaXMuZGlzYWJsZWQgPSBjYWxjdWxhdGVkQ29udGVudFdpZHRoIDw9IGFjdHVhbENvbnRlbnRXaWR0aDtcblxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIHJlc2l6ZSBldmVudCBvbiB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAgICovXG4gIHByb3RlY3RlZCBvYnNlcnZlSG9zdEVsZW1lbnRSZXNpemUoKTogT2JzZXJ2YWJsZTxSZXNpemVPYnNlcnZlckVudHJ5W10+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlciA9PiB7XG4gICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGVudHJpZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBsb2NhbCB2YXJpYWJsZXMgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaG9zdCBlbGVtZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZUVsZW1lbnRQcm9wZXJ0aWVzKCk6IHZvaWQge1xuICAgIHRoaXMuaG9zdEVsZW1lbnRUZXh0ID0gdGhpcy5ob3N0RWxlbWVudC5pbm5lclRleHQ7XG4gICAgdGhpcy5jb21wdXRlZFN0eWxlID0gdGhpcy53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICB0aGlzLmZvbnRTdHJpbmcgPSB0aGlzLmNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udCcpO1xuICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IHRoaXMuY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdsZXR0ZXItc3BhY2luZycpO1xuICB9XG59XG4iXX0=