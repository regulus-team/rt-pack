import { DOCUMENT } from '@angular/common';
import { Directive, Inject, Input, Optional, } from '@angular/core';
import { MAT_TOOLTIP_DEFAULT_OPTIONS, MAT_TOOLTIP_SCROLL_STRATEGY, MatTooltip, } from '@angular/material/tooltip';
import { WINDOW } from 'rt-platform';
import { Observable, Subscription } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/cdk/platform";
import * as i3 from "@angular/cdk/a11y";
import * as i4 from "@angular/cdk/bidi";
import * as i5 from "rt-define-stroke-width";
class RtOverflowTooltipDirective extends MatTooltip {
    rtDefineStrokeWidth;
    /** The message to be displayed in the tooltip if the element has not enough space. */
    rtOverflowTooltip;
    rtOverflowDisable = false;
    /** Host element of the directive. */
    hostElement;
    /** Text content of the host element. */
    hostElementText;
    /** CSS rules applied to the host element. */
    computedStyle;
    /** Font CSS style rule applied to the host element. */
    fontString;
    /** Letter spacing CSS style rule applied to the host element. */
    letterSpacing;
    paddingLeft;
    paddingRight;
    borderLeft;
    borderRight;
    /** Component subscriptions. Will be unsubscribed on destroy. */
    subscription = new Subscription();
    /** Global window object. */
    window;
    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document, rtDefineStrokeWidth, _window) {
        super(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document);
        this.rtDefineStrokeWidth = rtDefineStrokeWidth;
        // Assign host element.
        this.hostElement = _elementRef.nativeElement;
        // Assign global window object.
        this.window = _window;
    }
    ngOnInit() {
        // Apply provided tooltip text to the element.
        this.message = this.rtOverflowTooltip;
        // Subscribe to resize event on the host element and update tooltip display logic.
        this.subscription.add(this.observeHostElementResize().subscribe(() => this.updateElementDisplayLogic()));
    }
    updateElementDisplayLogic() {
        this.updateElementProperties();
        // Calculate the width of the spaces with the applied letter spacing rule.
        const letterSpacingAmendment = this.hostElement.innerText.length * parseFloat(this.letterSpacing);
        // Calculate the width of the text content with the applied font rule without actual rendering it.
        const calculatedStringWidth = this.rtDefineStrokeWidth.getTextWidth(this.hostElement.innerText, this.fontString);
        const calculatedContentWidth = calculatedStringWidth + letterSpacingAmendment;
        const area = parseFloat(this.borderLeft) + parseFloat(this.borderRight) + parseFloat(this.paddingLeft) + parseFloat(this.paddingRight);
        // Calculate the actual width of the host element.
        const actualContentWidth = this.hostElement.getBoundingClientRect().width - area;
        // Disable tooltip if the text content is not overflowing (all the content is on the page, so no need to show tooltip).
        this.disabled = calculatedContentWidth <= actualContentWidth || this.rtOverflowDisable;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * Observe resize event on the provided element.
     */
    observeHostElementResize() {
        return new Observable(subscriber => {
            const resizeObserver = new ResizeObserver(entries => {
                subscriber.next(entries);
            });
            resizeObserver.observe(this.hostElement);
            return () => {
                resizeObserver.unobserve(this.hostElement);
            };
        });
    }
    /**
     * Update local variables with the current state of the host element.
     */
    updateElementProperties() {
        this.hostElementText = this.hostElement.innerText;
        this.computedStyle = this.window.getComputedStyle(this.hostElement);
        this.fontString = this.computedStyle.getPropertyValue('font');
        this.letterSpacing = this.computedStyle.getPropertyValue('letter-spacing');
        this.paddingLeft = this.computedStyle.getPropertyValue('padding-left');
        this.paddingRight = this.computedStyle.getPropertyValue('padding-right');
        this.borderLeft = this.computedStyle.getPropertyValue('border-left');
        this.borderRight = this.computedStyle.getPropertyValue('border-right');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i1.ScrollDispatcher }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i2.Platform }, { token: i3.AriaDescriber }, { token: i3.FocusMonitor }, { token: MAT_TOOLTIP_SCROLL_STRATEGY }, { token: i4.Directionality, optional: true }, { token: MAT_TOOLTIP_DEFAULT_OPTIONS, optional: true }, { token: DOCUMENT, optional: true }, { token: i5.RtDefineStrokeWidthService }, { token: WINDOW, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: RtOverflowTooltipDirective, selector: "[rtOverflowTooltip]", inputs: { rtOverflowTooltip: "rtOverflowTooltip", rtOverflowDisable: "rtOverflowDisable" }, usesInheritance: true, ngImport: i0 });
}
export { RtOverflowTooltipDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rtOverflowTooltip]',
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i1.ScrollDispatcher }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i2.Platform }, { type: i3.AriaDescriber }, { type: i3.FocusMonitor }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_TOOLTIP_SCROLL_STRATEGY]
                }] }, { type: i4.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAT_TOOLTIP_DEFAULT_OPTIONS]
                }] }, { type: Document, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i5.RtDefineStrokeWidthService }, { type: Window, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [WINDOW]
                }] }]; }, propDecorators: { rtOverflowTooltip: [{
                type: Input
            }], rtOverflowDisable: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9ydC1vdmVyZmxvdy10b29sdGlwL3NyYy9saWIvcnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFDTCxTQUFTLEVBRVQsTUFBTSxFQUNOLEtBQUssRUFJTCxRQUFRLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLDJCQUEyQixFQUMzQiwyQkFBMkIsRUFDM0IsVUFBVSxHQUVYLE1BQU0sMkJBQTJCLENBQUM7QUFFbkMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNuQyxPQUFPLEVBQUMsVUFBVSxFQUFFLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQzs7Ozs7OztBQUU5QyxNQUdhLDBCQUEyQixTQUFRLFVBQVU7SUFzQzlDO0lBckNWLHNGQUFzRjtJQUM3RSxpQkFBaUIsQ0FBUztJQUUxQixpQkFBaUIsR0FBRyxLQUFLLENBQUM7SUFDbkMscUNBQXFDO0lBQzNCLFdBQVcsQ0FBYztJQUNuQyx3Q0FBd0M7SUFDOUIsZUFBZSxDQUFTO0lBQ2xDLDZDQUE2QztJQUNuQyxhQUFhLENBQXNCO0lBQzdDLHVEQUF1RDtJQUM3QyxVQUFVLENBQVU7SUFDOUIsaUVBQWlFO0lBQ3ZELGFBQWEsQ0FBUztJQUN0QixXQUFXLENBQVM7SUFDcEIsWUFBWSxDQUFTO0lBQ3JCLFVBQVUsQ0FBUztJQUNuQixXQUFXLENBQVM7SUFDOUIsZ0VBQWdFO0lBQy9DLFlBQVksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBQ25ELDRCQUE0QjtJQUNwQixNQUFNLENBQVM7SUFFdkIsWUFDRSxRQUFpQixFQUNqQixXQUF1QixFQUN2QixpQkFBbUMsRUFDbkMs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Y2VzQ29udGVudCI6WyJpbXBvcnQge0FyaWFEZXNjcmliZXIsIEZvY3VzTW9uaXRvcn0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHtEaXJlY3Rpb25hbGl0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHtPdmVybGF5LCBTY3JvbGxEaXNwYXRjaGVyfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQge1BsYXRmb3JtfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgTUFUX1RPT0xUSVBfREVGQVVMVF9PUFRJT05TLFxuICBNQVRfVE9PTFRJUF9TQ1JPTExfU1RSQVRFR1ksXG4gIE1hdFRvb2x0aXAsXG4gIE1hdFRvb2x0aXBEZWZhdWx0T3B0aW9ucyxcbn0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvdG9vbHRpcCc7XG5pbXBvcnQge0NTU0ZvbnQsIFJ0RGVmaW5lU3Ryb2tlV2lkdGhTZXJ2aWNlfSBmcm9tICdydC1kZWZpbmUtc3Ryb2tlLXdpZHRoJztcbmltcG9ydCB7V0lORE9XfSBmcm9tICdydC1wbGF0Zm9ybSc7XG5pbXBvcnQge09ic2VydmFibGUsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tydE92ZXJmbG93VG9vbHRpcF0nLFxufSlcbmV4cG9ydCBjbGFzcyBSdE92ZXJmbG93VG9vbHRpcERpcmVjdGl2ZSBleHRlbmRzIE1hdFRvb2x0aXAgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8qKiBUaGUgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgaWYgdGhlIGVsZW1lbnQgaGFzIG5vdCBlbm91Z2ggc3BhY2UuICovXG4gIEBJbnB1dCgpIHJ0T3ZlcmZsb3dUb29sdGlwOiBzdHJpbmc7XG5cbiAgQElucHV0KCkgcnRPdmVyZmxvd0Rpc2FibGUgPSBmYWxzZTtcbiAgLyoqIEhvc3QgZWxlbWVudCBvZiB0aGUgZGlyZWN0aXZlLiAqL1xuICBwcm90ZWN0ZWQgaG9zdEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAvKiogVGV4dCBjb250ZW50IG9mIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIHByb3RlY3RlZCBob3N0RWxlbWVudFRleHQ6IHN0cmluZztcbiAgLyoqIENTUyBydWxlcyBhcHBsaWVkIHRvIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIHByb3RlY3RlZCBjb21wdXRlZFN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uO1xuICAvKiogRm9udCBDU1Mgc3R5bGUgcnVsZSBhcHBsaWVkIHRvIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIHByb3RlY3RlZCBmb250U3RyaW5nOiBDU1NGb250O1xuICAvKiogTGV0dGVyIHNwYWNpbmcgQ1NTIHN0eWxlIHJ1bGUgYXBwbGllZCB0byB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICBwcm90ZWN0ZWQgbGV0dGVyU3BhY2luZzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcGFkZGluZ0xlZnQ6IHN0cmluZztcbiAgcHJvdGVjdGVkIHBhZGRpbmdSaWdodDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgYm9yZGVyTGVmdDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgYm9yZGVyUmlnaHQ6IHN0cmluZztcbiAgLyoqIENvbXBvbmVudCBzdWJzY3JpcHRpb25zLiBXaWxsIGJlIHVuc3Vic2NyaWJlZCBvbiBkZXN0cm95LiAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgLyoqIEdsb2JhbCB3aW5kb3cgb2JqZWN0LiAqL1xuICBwcml2YXRlIHdpbmRvdzogV2luZG93O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIF9vdmVybGF5OiBPdmVybGF5LFxuICAgIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIF9zY3JvbGxEaXNwYXRjaGVyOiBTY3JvbGxEaXNwYXRjaGVyLFxuICAgIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgIF9hcmlhRGVzY3JpYmVyOiBBcmlhRGVzY3JpYmVyLFxuICAgIF9mb2N1c01vbml0b3I6IEZvY3VzTW9uaXRvcixcbiAgICBASW5qZWN0KE1BVF9UT09MVElQX1NDUk9MTF9TVFJBVEVHWSkgX3Njcm9sbFN0cmF0ZWd5OiB1bmtub3duLFxuICAgIEBPcHRpb25hbCgpIF9kaXI6IERpcmVjdGlvbmFsaXR5LFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTUFUX1RPT0xUSVBfREVGQVVMVF9PUFRJT05TKVxuICAgICAgX2RlZmF1bHRPcHRpb25zOiBNYXRUb29sdGlwRGVmYXVsdE9wdGlvbnMsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChET0NVTUVOVCkgX2RvY3VtZW50OiBEb2N1bWVudCxcbiAgICBwcml2YXRlIHJ0RGVmaW5lU3Ryb2tlV2lkdGg6IFJ0RGVmaW5lU3Ryb2tlV2lkdGhTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoV0lORE9XKSBfd2luZG93OiBXaW5kb3csXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgX292ZXJsYXksXG4gICAgICBfZWxlbWVudFJlZixcbiAgICAgIF9zY3JvbGxEaXNwYXRjaGVyLFxuICAgICAgX3ZpZXdDb250YWluZXJSZWYsXG4gICAgICBfbmdab25lLFxuICAgICAgX3BsYXRmb3JtLFxuICAgICAgX2FyaWFEZXNjcmliZXIsXG4gICAgICBfZm9jdXNNb25pdG9yLFxuICAgICAgX3Njcm9sbFN0cmF0ZWd5LFxuICAgICAgX2RpcixcbiAgICAgIF9kZWZhdWx0T3B0aW9ucyxcbiAgICAgIF9kb2N1bWVudCxcbiAgICApO1xuICAgIC8vIEFzc2lnbiBob3N0IGVsZW1lbnQuXG4gICAgdGhpcy5ob3N0RWxlbWVudCA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAvLyBBc3NpZ24gZ2xvYmFsIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy53aW5kb3cgPSBfd2luZG93O1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBBcHBseSBwcm92aWRlZCB0b29sdGlwIHRleHQgdG8gdGhlIGVsZW1lbnQuXG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5ydE92ZXJmbG93VG9vbHRpcDtcblxuICAgIC8vIFN1YnNjcmliZSB0byByZXNpemUgZXZlbnQgb24gdGhlIGhvc3QgZWxlbWVudCBhbmQgdXBkYXRlIHRvb2x0aXAgZGlzcGxheSBsb2dpYy5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGQoXG4gICAgICB0aGlzLm9ic2VydmVIb3N0RWxlbWVudFJlc2l6ZSgpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZUVsZW1lbnREaXNwbGF5TG9naWMoKSksXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVFbGVtZW50RGlzcGxheUxvZ2ljKCk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlRWxlbWVudFByb3BlcnRpZXMoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIHNwYWNlcyB3aXRoIHRoZSBhcHBsaWVkIGxldHRlciBzcGFjaW5nIHJ1bGUuXG4gICAgY29uc3QgbGV0dGVyU3BhY2luZ0FtZW5kbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQuaW5uZXJUZXh0Lmxlbmd0aCAqIHBhcnNlRmxvYXQodGhpcy5sZXR0ZXJTcGFjaW5nKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIHRleHQgY29udGVudCB3aXRoIHRoZSBhcHBsaWVkIGZvbnQgcnVsZSB3aXRob3V0IGFjdHVhbCByZW5kZXJpbmcgaXQuXG4gICAgY29uc3QgY2FsY3VsYXRlZFN0cmluZ1dpZHRoID0gdGhpcy5ydERlZmluZVN0cm9rZVdpZHRoLmdldFRleHRXaWR0aCh0aGlzLmhvc3RFbGVtZW50LmlubmVyVGV4dCwgdGhpcy5mb250U3RyaW5nKTtcbiAgICBjb25zdCBjYWxjdWxhdGVkQ29udGVudFdpZHRoID0gY2FsY3VsYXRlZFN0cmluZ1dpZHRoICsgbGV0dGVyU3BhY2luZ0FtZW5kbWVudDtcblxuXG4gICAgY29uc3QgYXJlYSA9IHBhcnNlRmxvYXQodGhpcy5ib3JkZXJMZWZ0KSArIHBhcnNlRmxvYXQodGhpcy5ib3JkZXJSaWdodCkgKyBwYXJzZUZsb2F0KHRoaXMucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdCh0aGlzLnBhZGRpbmdSaWdodCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCB3aWR0aCBvZiB0aGUgaG9zdCBlbGVtZW50LlxuICAgIGNvbnN0IGFjdHVhbENvbnRlbnRXaWR0aCA9IHRoaXMuaG9zdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhcmVhO1xuXG4gICAgLy8gRGlzYWJsZSB0b29sdGlwIGlmIHRoZSB0ZXh0IGNvbnRlbnQgaXMgbm90IG92ZXJmbG93aW5nIChhbGwgdGhlIGNvbnRlbnQgaXMgb24gdGhlIHBhZ2UsIHNvIG5vIG5lZWQgdG8gc2hvdyB0b29sdGlwKS5cbiAgICB0aGlzLmRpc2FibGVkID0gY2FsY3VsYXRlZENvbnRlbnRXaWR0aCA8PSBhY3R1YWxDb250ZW50V2lkdGggfHwgdGhpcy5ydE92ZXJmbG93RGlzYWJsZTtcblxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIHJlc2l6ZSBldmVudCBvbiB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAgICovXG4gIHByb3RlY3RlZCBvYnNlcnZlSG9zdEVsZW1lbnRSZXNpemUoKTogT2JzZXJ2YWJsZTxSZXNpemVPYnNlcnZlckVudHJ5W10+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlciA9PiB7XG4gICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGVudHJpZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBsb2NhbCB2YXJpYWJsZXMgd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaG9zdCBlbGVtZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZUVsZW1lbnRQcm9wZXJ0aWVzKCk6IHZvaWQge1xuICAgIHRoaXMuaG9zdEVsZW1lbnRUZXh0ID0gdGhpcy5ob3N0RWxlbWVudC5pbm5lclRleHQ7XG4gICAgdGhpcy5jb21wdXRlZFN0eWxlID0gdGhpcy53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICB0aGlzLmZvbnRTdHJpbmcgPSB0aGlzLmNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udCcpO1xuICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IHRoaXMuY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdsZXR0ZXItc3BhY2luZycpO1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB0aGlzLmNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1sZWZ0Jyk7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB0aGlzLmNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpO1xuICAgIHRoaXMuYm9yZGVyTGVmdCA9IHRoaXMuY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItbGVmdCcpO1xuICAgIHRoaXMuYm9yZGVyUmlnaHQgPSB0aGlzLmNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXJpZ2h0Jyk7XG4gIH1cbn1cbiJdfQ==