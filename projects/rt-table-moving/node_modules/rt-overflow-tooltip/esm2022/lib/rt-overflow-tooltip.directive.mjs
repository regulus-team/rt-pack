import { DOCUMENT } from '@angular/common';
import { Directive, Inject, Input, Optional, } from '@angular/core';
import { MAT_TOOLTIP_DEFAULT_OPTIONS, MAT_TOOLTIP_SCROLL_STRATEGY, MatTooltip, } from '@angular/material/tooltip';
import { WINDOW } from 'rt-platform';
import { Observable, Subscription } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/cdk/platform";
import * as i3 from "@angular/cdk/a11y";
import * as i4 from "@angular/cdk/bidi";
import * as i5 from "rt-define-stroke-width";
class RtOverflowTooltipDirective extends MatTooltip {
    rtDefineStrokeWidth;
    /** The message to be displayed in the tooltip if the element has not enough space. */
    rtOverflowTooltip;
    /** Host element of the directive. */
    hostElement;
    /** Text content of the host element. */
    hostElementText;
    /** CSS rules applied to the host element. */
    computedStyle;
    /** Font CSS style rule applied to the host element. */
    fontString;
    /** Letter spacing CSS style rule applied to the host element. */
    letterSpacing;
    paddingLeft;
    paddingRight;
    borderLeft;
    borderRight;
    /** Component subscriptions. Will be unsubscribed on destroy. */
    subscription = new Subscription();
    /** Global window object. */
    window;
    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document, rtDefineStrokeWidth, _window) {
        super(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, _scrollStrategy, _dir, _defaultOptions, _document);
        this.rtDefineStrokeWidth = rtDefineStrokeWidth;
        // Assign host element.
        this.hostElement = _elementRef.nativeElement;
        // Assign global window object.
        this.window = _window;
    }
    ngOnInit() {
        // Apply provided tooltip text to the element.
        this.message = this.rtOverflowTooltip;
        // Subscribe to resize event on the host element and update tooltip display logic.
        this.subscription.add(this.observeHostElementResize().subscribe(() => this.updateElementDisplayLogic()));
    }
    updateElementDisplayLogic() {
        this.updateElementProperties();
        // Calculate the width of the spaces with the applied letter spacing rule.
        const letterSpacingAmendment = this.hostElement.innerText.length * parseFloat(this.letterSpacing);
        // Calculate the width of the text content with the applied font rule without actual rendering it.
        const calculatedStringWidth = this.rtDefineStrokeWidth.getTextWidth(this.hostElement.innerText, this.fontString);
        const calculatedContentWidth = calculatedStringWidth + letterSpacingAmendment;
        const area = parseFloat(this.borderLeft) + parseFloat(this.borderRight) + parseFloat(this.paddingLeft) + parseFloat(this.paddingRight);
        // Calculate the actual width of the host element.
        const actualContentWidth = this.hostElement.getBoundingClientRect().width - area;
        // Disable tooltip if the text content is not overflowing (all the content is on the page, so no need to show tooltip).
        this.disabled = calculatedContentWidth <= actualContentWidth;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * Observe resize event on the provided element.
     */
    observeHostElementResize() {
        return new Observable(subscriber => {
            const resizeObserver = new ResizeObserver(entries => {
                subscriber.next(entries);
            });
            resizeObserver.observe(this.hostElement);
            return () => {
                resizeObserver.unobserve(this.hostElement);
            };
        });
    }
    /**
     * Update local variables with the current state of the host element.
     */
    updateElementProperties() {
        this.hostElementText = this.hostElement.innerText;
        this.computedStyle = this.window.getComputedStyle(this.hostElement);
        this.fontString = this.computedStyle.getPropertyValue('font');
        this.letterSpacing = this.computedStyle.getPropertyValue('letter-spacing');
        this.paddingLeft = this.computedStyle.getPropertyValue('padding-left');
        this.paddingRight = this.computedStyle.getPropertyValue('padding-right');
        this.borderLeft = this.computedStyle.getPropertyValue('border-left');
        this.borderRight = this.computedStyle.getPropertyValue('border-right');
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i1.ScrollDispatcher }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i2.Platform }, { token: i3.AriaDescriber }, { token: i3.FocusMonitor }, { token: MAT_TOOLTIP_SCROLL_STRATEGY }, { token: i4.Directionality, optional: true }, { token: MAT_TOOLTIP_DEFAULT_OPTIONS, optional: true }, { token: DOCUMENT, optional: true }, { token: i5.RtDefineStrokeWidthService }, { token: WINDOW, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: RtOverflowTooltipDirective, selector: "[rtOverflowTooltip]", inputs: { rtOverflowTooltip: "rtOverflowTooltip" }, usesInheritance: true, ngImport: i0 });
}
export { RtOverflowTooltipDirective };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: RtOverflowTooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rtOverflowTooltip]',
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i1.ScrollDispatcher }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i2.Platform }, { type: i3.AriaDescriber }, { type: i3.FocusMonitor }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_TOOLTIP_SCROLL_STRATEGY]
                }] }, { type: i4.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAT_TOOLTIP_DEFAULT_OPTIONS]
                }] }, { type: Document, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i5.RtDefineStrokeWidthService }, { type: Window, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [WINDOW]
                }] }]; }, propDecorators: { rtOverflowTooltip: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9ydC1vdmVyZmxvdy10b29sdGlwL3NyYy9saWIvcnQtb3ZlcmZsb3ctdG9vbHRpcC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3pDLE9BQU8sRUFDTCxTQUFTLEVBRVQsTUFBTSxFQUNOLEtBQUssRUFJTCxRQUFRLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLDJCQUEyQixFQUMzQiwyQkFBMkIsRUFDM0IsVUFBVSxHQUVYLE1BQU0sMkJBQTJCLENBQUM7QUFFbkMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNuQyxPQUFPLEVBQUMsVUFBVSxFQUFFLFlBQVksRUFBQyxNQUFNLE1BQU0sQ0FBQzs7Ozs7OztBQUU5QyxNQUdhLDBCQUEyQixTQUFRLFVBQVU7SUFvQzlDO0lBbkNWLHNGQUFzRjtJQUM3RSxpQkFBaUIsQ0FBUztJQUNuQyxxQ0FBcUM7SUFDM0IsV0FBVyxDQUFjO0lBQ25DLHdDQUF3QztJQUM5QixlQUFlLENBQVM7SUFDbEMsNkNBQTZDO0lBQ25DLGFBQWEsQ0FBc0I7SUFDN0MsdURBQXVEO0lBQzdDLFVBQVUsQ0FBVTtJQUM5QixpRUFBaUU7SUFDdkQsYUFBYSxDQUFTO0lBQ3RCLFdBQVcsQ0FBUztJQUNwQixZQUFZLENBQVM7SUFDckIsVUFBVSxDQUFTO0lBQ25CLFdBQVcsQ0FBUztJQUM5QixnRUFBZ0U7SUFDL0MsWUFBWSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7SUFDbkQsNEJBQTRCO0lBQ3BCLE1BQU0sQ0FBUztJQUV2QixZQUNFLFFBQWlCLEVBQ2pCLFdBQXVCLEVBQ3ZCLGlCQUFtQyxFQUNuQyxpQkFBbUMsRUFDbkMsT0FBZSxFQUNmLFNBQW1CLEVBQ25CLGNBQTZCLEVBQzdCLGFBQTJCLEVBQ1UsZUFBd0IsRUFDakQsSUFBb0IsRUFFOUIsZUFBeUMsRUFDYixTQUFtQixFQUN6QyxtQkFBK0MsRUFDM0IsT0FBZTtRQUUzQyxLQUFLLENBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxpQkFBaUIsRUFDakIsaUJBQWlCLEVBQ2pCLE9BQU8sRUFDUCxTQUFTLEVBQ1QsY0FBYyxFQUNkLGFBQWEsRUFDYixlQUFlLEVBQ2YsSUFBSSxFQUNKLGVBQWUsRUFDZixTQUFTLENBQ1YsQ0FBQztRQWhCTSx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQTRCO1FBaUJ2RCx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDO1FBRTdDLCtCQUErQjtRQUMvQixJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQztJQUN4QixDQUFDO0lBRUQsUUFBUTtRQUVOLDhDQUE4QztRQUM5QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztRQUV0QyxrRkFBa0Y7UUFDbEYsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQ25CLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxDQUNsRixDQUFDO0lBQ0osQ0FBQztJQUVNLHlCQUF5QjtRQUM5QixJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztRQUUvQiwwRUFBMEU7UUFDMUUsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUVsRyxrR0FBa0c7UUFDbEcsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNqSCxNQUFNLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixDQUFDO1FBRzlFLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFdkksa0RBQWtEO1FBQ2xELE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFFakYsdUhBQXVIO1FBQ3ZILElBQUksQ0FBQyxRQUFRLEdBQUcsc0JBQXNCLElBQUksa0JBQWtCLENBQUM7SUFFL0QsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7T0FFRztJQUNPLHdCQUF3QjtRQUNoQyxPQUFPLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sY0FBYyxHQUFHLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNsRCxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzNCLENBQUMsQ0FBQyxDQUFDO1lBRUgsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDekMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1YsY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDN0MsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDTyx1QkFBdUI7UUFDL0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQztRQUNsRCxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3BFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDdkUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNyRSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDekUsQ0FBQzt1R0E1SFUsMEJBQTBCLDBPQStCM0IsMkJBQTJCLDJEQUVmLDJCQUEyQiw2QkFFM0IsUUFBUSx1RUFFUixNQUFNOzJGQXJDakIsMEJBQTBCOztTQUExQiwwQkFBMEI7MkZBQTFCLDBCQUEwQjtrQkFIdEMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUscUJBQXFCO2lCQUNoQzs7MEJBZ0NJLE1BQU07MkJBQUMsMkJBQTJCOzswQkFDbEMsUUFBUTs7MEJBQ1IsUUFBUTs7MEJBQUksTUFBTTsyQkFBQywyQkFBMkI7OzBCQUU5QyxRQUFROzswQkFBSSxNQUFNOzJCQUFDLFFBQVE7OzBCQUUzQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLE1BQU07NENBbkNuQixpQkFBaUI7c0JBQXpCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FyaWFEZXNjcmliZXIsIEZvY3VzTW9uaXRvcn0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHtEaXJlY3Rpb25hbGl0eX0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHtPdmVybGF5LCBTY3JvbGxEaXNwYXRjaGVyfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQge1BsYXRmb3JtfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgTUFUX1RPT0xUSVBfREVGQVVMVF9PUFRJT05TLFxuICBNQVRfVE9PTFRJUF9TQ1JPTExfU1RSQVRFR1ksXG4gIE1hdFRvb2x0aXAsXG4gIE1hdFRvb2x0aXBEZWZhdWx0T3B0aW9ucyxcbn0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvdG9vbHRpcCc7XG5pbXBvcnQge0NTU0ZvbnQsIFJ0RGVmaW5lU3Ryb2tlV2lkdGhTZXJ2aWNlfSBmcm9tICdydC1kZWZpbmUtc3Ryb2tlLXdpZHRoJztcbmltcG9ydCB7V0lORE9XfSBmcm9tICdydC1wbGF0Zm9ybSc7XG5pbXBvcnQge09ic2VydmFibGUsIFN1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tydE92ZXJmbG93VG9vbHRpcF0nLFxufSlcbmV4cG9ydCBjbGFzcyBSdE92ZXJmbG93VG9vbHRpcERpcmVjdGl2ZSBleHRlbmRzIE1hdFRvb2x0aXAgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8qKiBUaGUgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgaWYgdGhlIGVsZW1lbnQgaGFzIG5vdCBlbm91Z2ggc3BhY2UuICovXG4gIEBJbnB1dCgpIHJ0T3ZlcmZsb3dUb29sdGlwOiBzdHJpbmc7XG4gIC8qKiBIb3N0IGVsZW1lbnQgb2YgdGhlIGRpcmVjdGl2ZS4gKi9cbiAgcHJvdGVjdGVkIGhvc3RFbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgLyoqIFRleHQgY29udGVudCBvZiB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICBwcm90ZWN0ZWQgaG9zdEVsZW1lbnRUZXh0OiBzdHJpbmc7XG4gIC8qKiBDU1MgcnVsZXMgYXBwbGllZCB0byB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICBwcm90ZWN0ZWQgY29tcHV0ZWRTdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbjtcbiAgLyoqIEZvbnQgQ1NTIHN0eWxlIHJ1bGUgYXBwbGllZCB0byB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICBwcm90ZWN0ZWQgZm9udFN0cmluZzogQ1NTRm9udDtcbiAgLyoqIExldHRlciBzcGFjaW5nIENTUyBzdHlsZSBydWxlIGFwcGxpZWQgdG8gdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgcHJvdGVjdGVkIGxldHRlclNwYWNpbmc6IHN0cmluZztcbiAgcHJvdGVjdGVkIHBhZGRpbmdMZWZ0OiBzdHJpbmc7XG4gIHByb3RlY3RlZCBwYWRkaW5nUmlnaHQ6IHN0cmluZztcbiAgcHJvdGVjdGVkIGJvcmRlckxlZnQ6IHN0cmluZztcbiAgcHJvdGVjdGVkIGJvcmRlclJpZ2h0OiBzdHJpbmc7XG4gIC8qKiBDb21wb25lbnQgc3Vic2NyaXB0aW9ucy4gV2lsbCBiZSB1bnN1YnNjcmliZWQgb24gZGVzdHJveS4gKi9cbiAgcHJpdmF0ZSByZWFkb25seSBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gIC8qKiBHbG9iYWwgd2luZG93IG9iamVjdC4gKi9cbiAgcHJpdmF0ZSB3aW5kb3c6IFdpbmRvdztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBfc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcixcbiAgICBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBfbmdab25lOiBOZ1pvbmUsXG4gICAgX3BsYXRmb3JtOiBQbGF0Zm9ybSxcbiAgICBfYXJpYURlc2NyaWJlcjogQXJpYURlc2NyaWJlcixcbiAgICBfZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsXG4gICAgQEluamVjdChNQVRfVE9PTFRJUF9TQ1JPTExfU1RSQVRFR1kpIF9zY3JvbGxTdHJhdGVneTogdW5rbm93bixcbiAgICBAT3B0aW9uYWwoKSBfZGlyOiBEaXJlY3Rpb25hbGl0eSxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BVF9UT09MVElQX0RFRkFVTFRfT1BUSU9OUylcbiAgICAgIF9kZWZhdWx0T3B0aW9uczogTWF0VG9vbHRpcERlZmF1bHRPcHRpb25zLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIF9kb2N1bWVudDogRG9jdW1lbnQsXG4gICAgcHJpdmF0ZSBydERlZmluZVN0cm9rZVdpZHRoOiBSdERlZmluZVN0cm9rZVdpZHRoU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFdJTkRPVykgX3dpbmRvdzogV2luZG93LFxuICApIHtcbiAgICBzdXBlcihcbiAgICAgIF9vdmVybGF5LFxuICAgICAgX2VsZW1lbnRSZWYsXG4gICAgICBfc2Nyb2xsRGlzcGF0Y2hlcixcbiAgICAgIF92aWV3Q29udGFpbmVyUmVmLFxuICAgICAgX25nWm9uZSxcbiAgICAgIF9wbGF0Zm9ybSxcbiAgICAgIF9hcmlhRGVzY3JpYmVyLFxuICAgICAgX2ZvY3VzTW9uaXRvcixcbiAgICAgIF9zY3JvbGxTdHJhdGVneSxcbiAgICAgIF9kaXIsXG4gICAgICBfZGVmYXVsdE9wdGlvbnMsXG4gICAgICBfZG9jdW1lbnQsXG4gICAgKTtcbiAgICAvLyBBc3NpZ24gaG9zdCBlbGVtZW50LlxuICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuXG4gICAgLy8gQXNzaWduIGdsb2JhbCB3aW5kb3cgb2JqZWN0LlxuICAgIHRoaXMud2luZG93ID0gX3dpbmRvdztcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgLy8gQXBwbHkgcHJvdmlkZWQgdG9vbHRpcCB0ZXh0IHRvIHRoZSBlbGVtZW50LlxuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucnRPdmVyZmxvd1Rvb2x0aXA7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gcmVzaXplIGV2ZW50IG9uIHRoZSBob3N0IGVsZW1lbnQgYW5kIHVwZGF0ZSB0b29sdGlwIGRpc3BsYXkgbG9naWMuXG4gICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgdGhpcy5vYnNlcnZlSG9zdEVsZW1lbnRSZXNpemUoKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVFbGVtZW50RGlzcGxheUxvZ2ljKCkpLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRWxlbWVudERpc3BsYXlMb2dpYygpOiB2b2lkIHtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRQcm9wZXJ0aWVzKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIHRoZSBzcGFjZXMgd2l0aCB0aGUgYXBwbGllZCBsZXR0ZXIgc3BhY2luZyBydWxlLlxuICAgIGNvbnN0IGxldHRlclNwYWNpbmdBbWVuZG1lbnQgPSB0aGlzLmhvc3RFbGVtZW50LmlubmVyVGV4dC5sZW5ndGggKiBwYXJzZUZsb2F0KHRoaXMubGV0dGVyU3BhY2luZyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGNvbnRlbnQgd2l0aCB0aGUgYXBwbGllZCBmb250IHJ1bGUgd2l0aG91dCBhY3R1YWwgcmVuZGVyaW5nIGl0LlxuICAgIGNvbnN0IGNhbGN1bGF0ZWRTdHJpbmdXaWR0aCA9IHRoaXMucnREZWZpbmVTdHJva2VXaWR0aC5nZXRUZXh0V2lkdGgodGhpcy5ob3N0RWxlbWVudC5pbm5lclRleHQsIHRoaXMuZm9udFN0cmluZyk7XG4gICAgY29uc3QgY2FsY3VsYXRlZENvbnRlbnRXaWR0aCA9IGNhbGN1bGF0ZWRTdHJpbmdXaWR0aCArIGxldHRlclNwYWNpbmdBbWVuZG1lbnQ7XG5cblxuICAgIGNvbnN0IGFyZWEgPSBwYXJzZUZsb2F0KHRoaXMuYm9yZGVyTGVmdCkgKyBwYXJzZUZsb2F0KHRoaXMuYm9yZGVyUmlnaHQpICsgcGFyc2VGbG9hdCh0aGlzLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQodGhpcy5wYWRkaW5nUmlnaHQpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhY3R1YWwgd2lkdGggb2YgdGhlIGhvc3QgZWxlbWVudC5cbiAgICBjb25zdCBhY3R1YWxDb250ZW50V2lkdGggPSB0aGlzLmhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYXJlYTtcblxuICAgIC8vIERpc2FibGUgdG9vbHRpcCBpZiB0aGUgdGV4dCBjb250ZW50IGlzIG5vdCBvdmVyZmxvd2luZyAoYWxsIHRoZSBjb250ZW50IGlzIG9uIHRoZSBwYWdlLCBzbyBubyBuZWVkIHRvIHNob3cgdG9vbHRpcCkuXG4gICAgdGhpcy5kaXNhYmxlZCA9IGNhbGN1bGF0ZWRDb250ZW50V2lkdGggPD0gYWN0dWFsQ29udGVudFdpZHRoO1xuXG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgcmVzaXplIGV2ZW50IG9uIHRoZSBwcm92aWRlZCBlbGVtZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIG9ic2VydmVIb3N0RWxlbWVudFJlc2l6ZSgpOiBPYnNlcnZhYmxlPFJlc2l6ZU9ic2VydmVyRW50cnlbXT4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVyID0+IHtcbiAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoZW50cmllcyk7XG4gICAgICB9KTtcblxuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGxvY2FsIHZhcmlhYmxlcyB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBob3N0IGVsZW1lbnQuXG4gICAqL1xuICBwcm90ZWN0ZWQgdXBkYXRlRWxlbWVudFByb3BlcnRpZXMoKTogdm9pZCB7XG4gICAgdGhpcy5ob3N0RWxlbWVudFRleHQgPSB0aGlzLmhvc3RFbGVtZW50LmlubmVyVGV4dDtcbiAgICB0aGlzLmNvbXB1dGVkU3R5bGUgPSB0aGlzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgIHRoaXMuZm9udFN0cmluZyA9IHRoaXMuY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250Jyk7XG4gICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gdGhpcy5jb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2xldHRlci1zcGFjaW5nJyk7XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHRoaXMuY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLWxlZnQnKTtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHRoaXMuY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgdGhpcy5ib3JkZXJMZWZ0ID0gdGhpcy5jb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1sZWZ0Jyk7XG4gICAgdGhpcy5ib3JkZXJSaWdodCA9IHRoaXMuY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItcmlnaHQnKTtcbiAgfVxufVxuIl19